<!--Version 1-->
<!--This version includes the following mapping:
Map is a leaflet map with mapbox tiles.
Lines are drawn using leaflet API (hence it's styling)
Station are mapped to d3 changeStations.
line path is mapped to shape. Each line mapped to differrent color
Every relevant station (i.e. station where two lines intersect) is mapped to a circle with a text.
The best station to switch stations at has double mappings:
1. The better the station (=the shorter time), the bigger the station's icon.
 The waiting time is mapped to the circle's radius ([Max time - current time]), the bigger the better.
2. The better the station, the darker is the station's hue.
The waiting time is mapped to the circle's hue and indicated in a hover tooltip.
Coloring: the lines and the circle are 3 distinctive colors (red, blue and green). The station's colors received sequntial scaling.
Next iterations: suggestions:
- Cancel double mapping: map stations to icons and shortest waiting time to darkest hue.
- Add a legend for the waiting times
- Add a tooltip for the line
- Add origin & destination stations indication
-->
<!DOCTYPE html>
<html>
<!--import thr leaflet css-->
<link rel="stylesheet"
	href="http://cdn.leafletjs.com/leaflet-1.0.0-b1/leaflet.css" />
<link rel="stylesheet" type="text/css"
	href="https://syntagmatic.github.io/parallel-coordinates/d3.parcoords.css">
<!-- /resources/shaked.parcoords.css -->
<head>

<!--Script imports-->
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<script src="http://d3js.org/d3.v3.js" type="text/javascript"></script>

<script src="http://cdn.leafletjs.com/leaflet-1.0.0-b1/leaflet.js"></script>
<script
	src="https://syntagmatic.github.io/parallel-coordinates/d3.parcoords.js"></script>
<!-- https://shakedk.github.io/d3.parcoords.js	 -->
<script
	src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>




<!--General Styling-->
<style>
html, body {
	height: 100%;
	width: 100%;
	margin: 0;
	display: flex;
}

#parallelCoords {
	width: 800 px;
	flex: 1;
	/*flex-wrap: wrap;*/
	height: 80%;
}

#map {
	width: 600px;
	height: 100%;
}

#svg {
	/*position: relative;*/
	width: 100%;
}

path {
	stroke-width: 3px;
	stroke-opacity: 0.5;
}

.stationsText {
	stroke: black;
	stroke-width: 0.1px;
	fill: #67000d;
	font-size: 10pt;
	font-weight: bold;
}

.stations {
	stroke-width: 1px;
	stroke: black;
}

.lineStations {
	fill-opacity: 0;
	stroke-opacity: 0;
	;
}

.legend {
	padding: 6px 8px;
	font: 14px/16px Arial, Helvetica, sans-serif;
	background: white;
	background: rgba(255, 255, 255, 0.8);
	box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
	border-radius: 5px;
	line-height: 18px;
	color: #555;
}
</style>

</head>

<body>
	<div id="parallelCoords" class="parcoords">
		<p>
			<label for="sltBrushMode">Brush mode:</label> <select
				id="sltBrushMode">
			</select> <label id="lblPredicate" for="sltPredicate">Predicate:</label> <select
				id="sltPredicate">
				<option>AND</option>
				<option>OR</option>
			</select>
			<button id="btnReset">Reset Brushes</button>
		</p>
		<script type="text/javascript">
			
		</script>
	</div>
	<div id="map">
		<script type="text/javascript">
			//place holder for the parallel-coordinates draw
			var host = "localhost"; //"5.102.230.126"
			var parcoords = d3.parcoords()("#parallelCoords");
			var parCoordData;
			//Importing the mapbox tiles layer. For our purposes, the example map is sufficient
			var mapboxTiles = L
					.tileLayer(
							'https://api.mapbox.com/v4/mapbox.streets/{z}/{x}/{y}.png?access_token={token}',
							{
								attribution : 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="http://mapbox.com">Mapbox</a>',
								mapId : 'mapbox-streets',
								token : 'pk.eyJ1Ijoic2hha2VkayIsImEiOiJjaWxjYzVxbzIwMDZud2dsejg3Zmw3dncyIn0.1mxg8ZqXNXzMZ2OkH9os5A'
							});
			//Importing the map from leaflet and adding the tiles layer.
			//The initial view is centered to Tel Aviv, according to the example info (lines 171 and 222).
			var map = L.map('map').addLayer(mapboxTiles).setView(
					[ 32.095881, 34.794564 ], 12.5);
			var popup = new L.Popup({
				autoPan : false
			});

			// Initialize the SVG layer
			L.svg().addTo(map);
			// Categorical colors for 2 lines routes and the optional changing station's colors
			var mappingColors = {
				"areaBorderColor" : "rgb(152,78,163)",
			};
			// colors used for PC & Map
			var colors = [ '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8',
					'#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837' ];//['#8e0152','#c51b7d','#de77ae','#f1b6da','#fde0ef','#e6f5d0','#b8e186','#7fbc41','#4d9221','#276419'];

			var irrelevantcolor = "white";

			//Holds the hues that will be assigned for the waiting time mapping (the station changeStations color).
			//The actual setting is done after the relevant number of optional changing station is calculated.
			var stationsHues;
			// We pick up the SVG from the map object
			var svg = d3.select(map.getPanes().overlayPane).append("svg"), g = svg
					.append("g").attr("class", "leaflet-zoom-hide");
			//Styling variables used areas border
			var sAreaStyle = {
				"fillColor" : mappingColors.areaBorderColor
			};
			var areasLayer;

			draw_areas_on_map = function() {
				d3.json('http://' + host + ':8080/areas', function(data) {
					areasLayer = L.geoJson(data, {
						style : getAreaStyle,
						onEachFeature : onEachFeature
					}).addTo(map);
				})
			}
			var color = function(d) {
				if (d >= 0 && d <= colors.length) {
					return colors[d];
				}
				return irrelevantcolor;
				//	return 'orange';
			};

			function getAreaStyle(feature) {
				return {
					weight : 0.5,
					opacity : 0.5,
					color : 'black',
					fillOpacity : 0.7,
					fillColor : color(feature.properties.styleHash),
				};
			}

			//Reapint Areas back to default paint
			function rePaintAreas() {
				areasLayer.eachLayer(function(layer) {
					layer.setStyle(getAreaStyle(layer.feature));
				});
			}

			function onEachFeature(feature, layer) {
				var AreaID = feature.properties.Name;
				layer._leaflet_id = AreaID;
				layer.on({
					mousemove : mousemove,
					mouseout : mouseout,
					text : AreaID
				});
			}

			map.on('click', function(e) {
				parcoords.unhighlight();
			});
			var closeTooltip;

			function mousemove(e) {
				//Highlight the cooresponding line in the PC chart
				parLineHightlight(e);
				var layer = e.target;

				popup.setLatLng(e.latlng);
				popup.setContent('<div class="marker-title">Area ID: '
						+ layer.feature.properties.Name + '</div>');

				if (!popup._map)
					popup.openOn(map);
				window.clearTimeout(closeTooltip);

				// highlight feature
				layer.setStyle({
					weight : 2,
					opacity : 0.3,
					fillOpacity : 0.9
				});
				if (!L.Browser.ie && !L.Browser.opera) {
					layer.bringToFront();
				}
			}

			function mouseout(e) {
				areasLayer.resetStyle(e.target);
			}

			function zoomToFeature(e) {
				map.fitBounds(e.target.getBounds());
			}

			//Adding a legend with sequential horizontal bar for easy access
			var legend = L.control({
				position : 'bottomright'
			});
			legend.onAdd = function(map) {
				var div = L.DomUtil.create('div', 'legend');
				div.innerHTML += '<p style="margin:auto; background: linear-gradient(to right, '
						+ colors + ')"</p>' + '<br>';
				div.innerHTML += '<p style="font-weight: bold"> Lowest Accessibility &#8596 Highest Accessibility</p>';
				return div;
			};
			legend.addTo(map);

			/*			var button = L.control({
			 position : 'topright'
			 });
			 button.onAdd = function(map) {
			 var div = L.DomUtil.create('div', 'legend');
			 div.innerHTML = '<form><input id="command" type="checkbox"/>Add Stations<br><input id="areas" type="checkbox"/>Add Areas</form>';
			 return div;
			 };
			 button.addTo(map); 
			 // add the event handler
			 function handleCommand() {
			 // alert("Clicked, checked = " + this.checked);
			 if (this.checked) {
			 $.ajax({
			 type : "GET",
			 contentType : "application/json; charset=utf-8",
			 url : 'http://' + host + '/:8080/stations',
			 dataType : 'json',
			 async : true,
			 data : "{}",
			 success : function(data) {
			 //var pos_data = data;
			 draw_stations_on_map(data);
			 },
			 error : function(result) {

			 }
			 })
			 } else {
			 stationLayer.clearLayers();
			 } 
			 draw_stations_on_map = function(data) {
			 stationLayer = L.geoJson(data, {
			 style : getMarkerStyle
			 }).addTo(map);
			 }

			 function getMarkerStyle() {
			 return {
			 color : 'black',
			 iconUrl : 'none'
			 };
			 }
			 } 
			 //Adding a chekcbox for areas
			 var button = L.control({
			 position : 'topright'
			 });

			 // add the event handler
			 function handleAreaCommand() {
			 if (this.checked) {
			 //Getting the area polygons from the server
			 $.ajax({
			 type : "GET",
			 contentType : "application/json; charset=utf-8",
			 url : 'http://' + host + ':8080/areas',
			 dataType : 'json',
			 async : true,
			 data : "{}",
			 success : function(data) {
			 //var pos_data = data;
			 draw_areas_on_map(data);
			 },
			 error : function(result) {

			 }
			 })
			 } else {
			 areasLayer.clearLayers();
			 }
			 }
			 document.getElementById("areas").addEventListener("click",
			 handleAreaCommand, false);
			 document.getElementById("command").addEventListener("click",
			 handleCommand, false);
			 */

			//Adding the areas and the Pc right upon page load
			$(document).ready(function() {
				draw_areas_on_map();
				draw_par_coords();
			});
			// load csv file and create the chart

			draw_par_coords = function() {
				//TODO: Needs to use this coloring and not array
				//var colors = d3.scale.category20b();
				d3.csv('http://' + host + ':8080/subIndicesDataForJSON',
						function(data) {
							parCoordData = data;
							//var colorgen = d3.scale.ordinal().range(colors);

							//creating a SQRT scale							
							var sqrtScale = function(columName) {
								range = parcoords.height()
										- parcoords.margin().top
										- parcoords.margin().bottom;
								min = d3.min(data, function(d) {
									return parseInt(d[columName]);
								});
								max = d3.max(data, function(d) {
									return parseFloat(d[columName]);
								});
								return d3.scale.sqrt().domain([ min, max ])
										.range([ range, 1 ]);
							}

							var dimensions = {
								"AreaID" : {
									title : 'Area ID',
								},
								"Stops" : {
									title : 'Number of Stops',
									//Scaling the yAxis as sqrt to be less condensed
									yscale : sqrtScale('Stops'),
								},
								"Area" : {
									title : 'Area (km^2)',
									//Scaling the yAxis as sqrt to be less condensed
									yscale : sqrtScale('Area'),
								},
								"Population" : {
									title : 'Population',
									//Scaling the yAxis as sqrt to be less condensed
									yscale : sqrtScale('Population'),
								},
								"Areas Average Frequencies" : {
									title : 'Average Freq.',
								},
								"Median Income" : {
									title : 'Median Income',
								},
								"STAI" : {
									title : 'STAI',
								},
								"AreadID" : {
									title : 'shaked8',
								},
							};

							var pcColor = function(d) {
								return color(Math.floor(d.STAI));
							}
							//Filtering out business areas, that it STAI = -1
							data = data.filter(function(d) {
								return parseFloat(d.STAI) > -1
							})
							parcoords.data(data).hideAxis([ "name" ]).color(
									pcColor).dimensions(dimensions)
									.detectDimensions().render().alpha(0.5)
									.render().shadows().reorderable()
									.composite("darken").margin({
										top : 24,
										left : 150,
										bottom : 12,
										right : 0
									}).mode("queue").render().brushMode(
											"1D-axes"); // enable brushing

							//styling the text
							parcoords.svg.selectAll("text").style("font",
									"20px sans-serif");

							//styling the axes
							/*	parcoords.svg.selectAll(".ctx.foreground.lineWidth").style(
										"lineWidth ", "6");*/

							parcoords.svg.selectAll(".dimension text.label")
									.style("color", "red");

							// update map hightlight brush event
							parcoords.on("brush", function(d) {
								if (areasLayer) {
									//Making the entire layer more transperent
									areasLayer.setStyle({
										fillOpacity : 0.1,
									});
									d.forEach(function(polygon) {
										selectPolygon = areasLayer
												.getLayer(polygon.AreaID);
										setAreaHighlighted(selectPolygon);
									});
								}
							});
							
							//Mouse highlight in PC
						d3.select("#parallelCoords svg").on("mouseover", function() {
								var mousePosition = d3.mouse(this);
								highlightLineOnClick(mousePosition, true); //true will also add tooltip
							})

							var sltBrushMode = d3.select('#sltBrushMode')
							sltBrushMode.selectAll('option').data(
									parcoords.brushModes()).enter().append(
									'option').text(function(d) {
								return d;
							});

							sltBrushMode.on('change', function() {
								parcoords.brushMode(this.value);
								switch (this.value) {
								case 'None':
									d3.select("#pStrums").style("visibility",
											"hidden");
									d3.select("#lblPredicate").style(
											"visibility", "hidden");
									d3.select("#sltPredicate").style(
											"visibility", "hidden");
									d3.select("#btnReset").style("visibility",
											"hidden");
									break;
								case '2D-strums':
									d3.select("#pStrums").style("visibility",
											"visible");
									break;
								default:
									d3.select("#pStrums").style("visibility",
											"hidden");
									d3.select("#lblPredicate").style(
											"visibility", "visible");
									d3.select("#sltPredicate").style(
											"visibility", "visible");
									d3.select("#btnReset").style("visibility",
											"visible");
									break;
								}
							});
							d3.select('#btnReset').on('click', function() {
								parcoords.brushReset();
								rePaintAreas();
							})
							d3.select('#sltPredicate').on('change', function() {
								parcoords.brushPredicate(this.value);
							});
						});
			};

			//Highlight the cooresponding line in the PC chart
			parLineHightlight = function(e) {
				parcoords.highlight(parCoordData.filter(function(d) {
					return d.AreaID === e.target.feature.properties.Name;
				}));
			};

			setAreaHighlighted = function(polygon) {
				polygon.setStyle({
					fillOpacity : 1,
				//					borderColor : 'pink'
				});
			};

		</script>
	</div>

</body>

</html>