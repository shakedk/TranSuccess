<!--Version 1-->
<!--This version includes the following mapping:
Map is a leaflet map with mapbox tiles.
Lines are drawn using leaflet API (hence it's styling)
Station are mapped to d3 changeStations.
line path is mapped to shape. Each line mapped to differrent color
Every relevant station (i.e. station where two lines intersect) is mapped to a circle with a text.
The best station to switch stations at has double mappings:
1. The better the station (=the shorter time), the bigger the station's icon.
 The waiting time is mapped to the circle's radius ([Max time - current time]), the bigger the better.
2. The better the station, the darker is the station's hue.
The waiting time is mapped to the circle's hue and indicated in a hover tooltip.
Coloring: the lines and the circle are 3 distinctive colors (red, blue and green). The station's colors received sequntial scaling.
Next iterations: suggestions:
- Cancel double mapping: map stations to icons and shortest waiting time to darkest hue.
- Add a legend for the waiting times
- Add a tooltip for the line
- Add origin & destination stations indication
-->
<!DOCTYPE html>
<html>
<!--import thr leaflet css-->
<link rel="stylesheet"
	href="http://cdn.leafletjs.com/leaflet-1.0.0-b1/leaflet.css" />
<link rel="stylesheet" type="text/css"
	href="https://syntagmatic.github.io/parallel-coordinates/d3.parcoords.css">
<!-- /resources/shaked.parcoords.css -->
<head>

<!--Script imports-->
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<script src="http://d3js.org/d3.v3.js" type="text/javascript"></script>

<script src="http://cdn.leafletjs.com/leaflet-1.0.0-b1/leaflet.js"></script>
<script
	src="https://syntagmatic.github.io/parallel-coordinates/d3.parcoords.js"></script>
<!-- http://shakedk.github.io/d3.parcoords.js -->
<script
	src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>




<!--General Styling-->
<style>
html, body {
	height: 100%;
	width: 100%;
	margin: 0;
	display: flex;
}

#parallelCoords {
	/*width: 800 px;*/
	flex: 1;
	flex-wrap: wrap;
	height: 80%;
}

#map {
	width: 600px;
	height: 100%;
}

svg {
	position: relative;
}

path {
	stroke-width: 3px;
	stroke-opacity: 0.5;
}

.stationsText {
	stroke: black;
	stroke-width: 0.1px;
	fill: #67000d;
	font-size: 10pt;
	font-weight: bold;
}

.stations {
	stroke-width: 1px;
	stroke: black;
}

.lineStations {
	fill-opacity: 0;
	stroke-opacity: 0;
	;
}

.legend {
	padding: 6px 8px;
	font: 14px/16px Arial, Helvetica, sans-serif;
	background: white;
	background: rgba(255, 255, 255, 0.8);
	box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
	border-radius: 5px;
	line-height: 18px;
	color: #555;
}
</style>

</head>

<body>
	<div id="parallelCoords" class="parcoords">
		<p>
			<label for="sltBrushMode">Brush mode:</label> <select
				id="sltBrushMode">
			</select> <label id="lblPredicate" for="sltPredicate">Predicate:</label> <select
				id="sltPredicate">
				<option>AND</option>
				<option>OR</option>
			</select>
			<button id="btnReset">Reset Brushes</button>
		</p>
		<script type="text/javascript">
			
		</script>
		<div id="grid"></div>
	</div>
	<div id="map">
		<script type="text/javascript">
			//place holder for the parallel-coordinates draw
			var host = "localhost"; //"5.102.230.126"
			var parcoords = d3.parcoords()("#parallelCoords");
			var parCoordData;
			//Importing the mapbox tiles layer. For our purposes, the example map is sufficient
			var mapboxTiles = L
					.tileLayer(
							'https://api.mapbox.com/v4/mapbox.streets/{z}/{x}/{y}.png?access_token={token}',
							{
								attribution : 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="http://mapbox.com">Mapbox</a>',
								mapId : 'mapbox-streets',
								token : 'pk.eyJ1Ijoic2hha2VkayIsImEiOiJjaWxjYzVxbzIwMDZud2dsejg3Zmw3dncyIn0.1mxg8ZqXNXzMZ2OkH9os5A'
							});
			//Importing the map from leaflet and adding the tiles layer.
			//The initial view is centered to Tel Aviv, according to the example info (lines 171 and 222).
			var map = L.map('map').addLayer(mapboxTiles).setView(
					[ 32.07452, 34.78875 ], 13);
			var popup = new L.Popup({
				autoPan : false
			});

			// Initialize the SVG layer
			L.svg().addTo(map);
			// Categorical colors for 2 lines routes and the optional changing station's colors
			var mappingColors = {
				"areaBorderColor" : "rgb(152,78,163)",
			};
			// colors used for PC & Map
			var colors = ['#276419','#4d9221','#7fbc41','#b8e186','#e6f5d0','#fde0ef','#f1b6da','#de77ae','#c51b7d','#8e0152'];
						 
			
			var irrelevantcolor = "white";

			//Holds the hues that will be assigned for the waiting time mapping (the station changeStations color).
			//The actual setting is done after the relevant number of optional changing station is calculated.
			var stationsHues;
			// We pick up the SVG from the map object
			var svg = d3.select(map.getPanes().overlayPane).append("svg"), g = svg
					.append("g").attr("class", "leaflet-zoom-hide");
			//Styling variables used areas border
			var sAreaStyle = {
				"fillColor" : mappingColors.areaBorderColor
			};
			var areasLayer;

			draw_areas_on_map = function(data) {
				areasLayer = L.geoJson(data, {
					style : getStyle,
					onEachFeature : onEachFeature
				}).addTo(map);
			}

			var color = function(d) {			
				if (d > 0 && d <= colors.length) {
					return colors[d];
				}
				else if (d < 0){
				return irrelevantcolor ;
				}
				else return "orange";
				//Something is bad with colors
			};
			
			function getStyle(feature) {
				return {
					weight : 0.5,
					opacity : 0.5,
					color : 'black',
					fillOpacity : 0.7,
					fillColor : color(feature.properties.styleHash),
				};
			}

			//Reapint Areas back to default paint
			function rePaintAreas() {
				areasLayer.eachLayer(function(layer) {
					layer.setStyle(getStyle(layer.feature));
				});
			}



			function onEachFeature(feature, layer) {
				var areaId = feature.properties.Name;
				layer._leaflet_id = areaId;
				layer.on({
					mousemove : mousemove,
					mouseout : mouseout,
					text : areaId
				});
			}

			map.on('click', function(e) {
				parcoords.unhighlight();
			});
			var closeTooltip;

			function mousemove(e) {
				//Highlight the cooresponding line in the PC chart
				parLineHightlight(e);
				var layer = e.target;

				popup.setLatLng(e.latlng);
				popup.setContent('<div class="marker-title">Area ID: '
						+ layer.feature.properties.Name + '</div>');

				if (!popup._map)
					popup.openOn(map);
				window.clearTimeout(closeTooltip);

				// highlight feature
				layer.setStyle({
					weight : 2,
					opacity : 0.3,
					fillOpacity : 0.9
				});
				if (!L.Browser.ie && !L.Browser.opera) {
					layer.bringToFront();
				}
			}

			function mouseout(e) {
				areasLayer.resetStyle(e.target);
			}

			function zoomToFeature(e) {
				map.fitBounds(e.target.getBounds());
			}

			//Adding a legend with sequential horizontal bar for easy access
			var legend = L.control({
				position : 'bottomright'
			});
			legend.onAdd = function(map) {
				var div = L.DomUtil.create('div', 'legend');
				div.innerHTML += '<p style="margin:auto; background: linear-gradient(to right, '
						+ colors + ')"</p>' + '<br>';
				div.innerHTML += '<p style="font-weight: bold"> Highest Accessibility &#8596 Lowest Accessibility</p>';
				return div;
			};
			legend.addTo(map);

			//Adding a legend with sequential horizontal bar for easy access
			var button = L.control({
				position : 'topright'
			});
			button.onAdd = function(map) {
				var div = L.DomUtil.create('div', 'legend');
				div.innerHTML = '<form><input id="command" type="checkbox"/>Add Stations<br><input id="areas" type="checkbox"/>Add Areas</form>';
				return div;
			};
			button.addTo(map);
			// add the event handler
			function handleCommand() {
				// alert("Clicked, checked = " + this.checked);
				if (this.checked) {
					$.ajax({
						type : "GET",
						contentType : "application/json; charset=utf-8",
						url : 'http://' + host + '/:8080/stations',
						dataType : 'json',
						async : true,
						data : "{}",
						success : function(data) {
							//var pos_data = data;
							draw_stations_on_map(data);
						},
						error : function(result) {

						}
					})
				} else {
					stationLayer.clearLayers();
				}
				draw_stations_on_map = function(data) {
					stationLayer = L.geoJson(data, {
						style : getMarkerStyle
					}).addTo(map);
				}

				function getMarkerStyle() {
					return {
						color : 'black',
						iconUrl : 'none'
					};
				}
			}
			//Adding a legend with sequential horizontal bar for easy access
			var button = L.control({
				position : 'topright'
			});

			// add the event handler
			function handleAreaCommand() {
				if (this.checked) {
					//Getting the area polygons from the server
					$.ajax({
						type : "GET",
						contentType : "application/json; charset=utf-8",
						url : 'http://' + host + ':8080/areas',
						dataType : 'json',
						async : true,
						data : "{}",
						success : function(data) {
							//var pos_data = data;
							draw_areas_on_map(data);
						},
						error : function(result) {

						}
					})
				} else {
					areasLayer.clearLayers();
				}
			}
			document.getElementById("areas").addEventListener("click",
					handleAreaCommand, false);
			document.getElementById("command").addEventListener("click",
					handleCommand, false);

			//Using SVG, iterating the stations and displaying only the
			//change stations (in this example there are only 8 stations)

			$(document).ready(function() {
				draw_par_coords();
			});
			// load csv file and create the chart

			draw_par_coords = function() {
				//TODO: Needs to use this coloring and not array
				//var colors = d3.scale.category20b();
				d3.csv('http://' + host + ':8080/subIndicesDataForJSON',
						function(data) {
							parCoordData = data;
							//var colorgen = d3.scale.ordinal().range(colors);
							
							//creating a SQRT scale							
							var sqrtScale = function(columName) {
								range = parcoords.height()
										- parcoords.margin().top
										- parcoords.margin().bottom;
								min = d3.min(data, function(d) {
									return parseInt(d[columName]);
								});
								max = d3.max(data, function(d) {
									return parseFloat(d[columName]);
								});
								return d3.scale.sqrt().domain([ min, max ])
										.range([ range, 1 ]);
							}

							var dimensions = {
								"AreaID" : {
									title : 'Area ID',
								},
								"Stops" : {
									title : 'Number of Stops',
									yscale : sqrtScale('Stops'),
								},
								"Area" : {
									title : 'Area (km^2)',
									yscale : sqrtScale('Area'),
								},
								"Population" : {
									title : 'Population',
									yscale : sqrtScale('Population'),
								},
								"Areas Average Frequencies" : {
									title : 'Average Freq.',
								},
								"Median Income" : {
									title : 'Median Income',
								},
								"STAI" : {
									title : 'STAI',
								},
								"AreadID" : {
									title : 'shaked8',
								},
							};

							var pcColor = function (d) {
								return color(Math.floor(d.STAI));
							}
							//Filtering out business areas, that it STAI = -1
							data = data.filter(function(d) { return parseFloat(d.STAI) > -1})
							parcoords.data(data).hideAxis([ "name" ]).color(
									pcColor).dimensions(dimensions)
									.detectDimensions().render().alpha(0.7)
									.render().shadows().reorderable()
									.composite("darken").margin({
										top : 24,
										left : 150,
										bottom : 12,
										right : 0
									}).mode("queue").render().brushMode(
											"1D-axes"); // enable brushing

							parcoords.svg.selectAll("text").style("font",
									"20px sans-serif");

							// update map hightlight brush event
							parcoords.on("brush", function(d) {
								//areasLayer.eachLayer(function(layer) {
								/*setHighlighted(layer, doesRelate(
										layer._polygonId, selectedId));*/
								//});
								//map.setHighlighted(areasLayer.doesRelate(layer._polygonId, selectedId));
								if (areasLayer) {
									//Making the entire layer more transperent
									areasLayer.setStyle({
										fillOpacity : 0.2,
									});
									d.forEach(function(polygon) {
										selectPolygon = areasLayer
												.getLayer(polygon.AreaID);
										setAreaHighlighted(selectPolygon);
									});
								}
							});

							var sltBrushMode = d3.select('#sltBrushMode')
							sltBrushMode.selectAll('option').data(
									parcoords.brushModes()).enter().append(
									'option').text(function(d) {
								return d;
							});

							sltBrushMode.on('change', function() {
								parcoords.brushMode(this.value);
								switch (this.value) {
								case 'None':
									d3.select("#pStrums").style("visibility",
											"hidden");
									d3.select("#lblPredicate").style(
											"visibility", "hidden");
									d3.select("#sltPredicate").style(
											"visibility", "hidden");
									d3.select("#btnReset").style("visibility",
											"hidden");
									break;
								case '2D-strums':
									d3.select("#pStrums").style("visibility",
											"visible");
									break;
								default:
									d3.select("#pStrums").style("visibility",
											"hidden");
									d3.select("#lblPredicate").style(
											"visibility", "visible");
									d3.select("#sltPredicate").style(
											"visibility", "visible");
									d3.select("#btnReset").style("visibility",
											"visible");
									break;
								}
							});
							d3.select('#btnReset').on('click', function() {
								parcoords.brushReset();
								rePaintAreas();
							})
							d3.select('#sltPredicate').on('change', function() {
								parcoords.brushPredicate(this.value);
							});
						});
			};

			//Highlight the cooresponding line in the PC chart
			parLineHightlight = function(e) {
				parcoords.highlight(parCoordData.filter(function(d) {
					return d.areaId === e.target.feature.properties.Name;
				}));
			};

			setAreaHighlighted = function(polygon) {
				polygon.setStyle({
					fillOpacity : 1,
				//					borderColor : 'pink'
				});
			};

			///////////////////////////////HIGHILIGHT PAAr/////////////////////////////
			/*
			 //add hover event
			 d3.select("#parallelCoords svg").on("mousemove", function() {
			 var mousePosition = d3.mouse(this);
			 highlightLineOnClick(mousePosition, true); //true will also add tooltip
			 }).on("mouseout", function() {
			 cleanTooltip();
			 parcoords.unhighlight();
			 });

			 // update color and font weight of chart based on axis selection
			 // modified from here: https://syntagmatic.github.io/parallel-coordinates/
			 function update_colors(dimension) {
			 // change the fonts to bold
			 parcoords.svg.selectAll(".dimension").style("font-weight",
			 "normal").filter(function(d) {
			 return d == dimension;
			 }).style("font-weight", "bold");

			 // change color of lines
			 // set domain of color scale
			 var values = parcoords.data().map(function(d) {
			 return parseFloat(d[dimension])
			 });
			 color_set.domain([ d3.min(values), d3.max(values) ]);

			 // change colors for each line
			 parcoords.color(function(d) {
			 return color_set([ d[dimension] ])
			 }).render();
			 };

			 // Add highlight for every line on click
			 function getCentroids(data) {
			 // this function returns centroid points for data. I had to change the source
			 // for parallelcoordinates and make compute_centroids public.
			 // I assume this should be already somewhere in graph and I don't need to recalculate it
			 // but I couldn't find it so I just wrote this for now
			 var margins = parcoords.margin();
			 var graphCentPts = [];

			 data.forEach(function(d) {

			 var initCenPts = parcoords.compute_centroids(d).filter(
			 function(d, i) {
			 return i % 2 == 0;
			 });

			 // move points based on margins
			 var cenPts = initCenPts
			 .map(function(d) {
			 return [ d[0] + margins["left"],
			 d[1] + margins["top"] ];
			 });

			 graphCentPts.push(cenPts);
			 });

			 return graphCentPts;
			 }

			 function getActiveData() {
			 // I'm pretty sure this data is already somewhere in graph
			 if (parcoords.brushed() != false)
			 return parcoords.brushed();
			 return parcoords.data();
			 }

			 function isOnLine(startPt, endPt, testPt, tol) {
			 // check if test point is close enough to a line
			 // between startPt and endPt. close enough means smaller than tolerance
			 var x0 = testPt[0];
			 var y0 = testPt[1];
			 var x1 = startPt[0];
			 var y1 = startPt[1];
			 var x2 = endPt[0];
			 var y2 = endPt[1];
			 var Dx = x2 - x1;
			 var Dy = y2 - y1;
			 var delta = Math.abs(Dy * x0 - Dx * y0 - x1 * y2 + x2 * y1)
			 / Math.sqrt(Math.pow(Dx, 2) + Math.pow(Dy, 2));
			 //console.log(delta);
			 if (delta <= tol)
			 return true;
			 return false;
			 }

			 function findAxes(testPt, cenPts) {
			 // finds between which two axis the mouse is
			 var x = testPt[0];
			 var y = testPt[1];

			 // make sure it is inside the range of x
			 if (cenPts[0][0] > x)
			 return false;
			 if (cenPts[cenPts.length - 1][0] < x)
			 return false;

			 // find between which segment the point is
			 for (var i = 0; i < cenPts.length; i++) {
			 if (cenPts[i][0] > x)
			 return i;
			 }
			 }

			 function cleanTooltip() {
			 // removes any object under #tooltip is
			 parcoords.svg.selectAll("#tooltip").remove();
			 }

			 function addTooltip(clicked, clickedCenPts) {

			 // sdd tooltip to multiple clicked lines
			 var clickedDataSet = [];
			 var margins = parcoords.margin()

			 // get all the values into a single list
			 // I'm pretty sure there is a better way to write this is Javascript
			 for (var i = 0; i < clicked.length; i++) {
			 for (var j = 0; j < clickedCenPts[i].length; j++) {
			 var text = d3.values(clicked[i])[j];
			 // not clean at all!
			 var x = clickedCenPts[i][j][0] - margins.left;
			 var y = clickedCenPts[i][j][1] - margins.top;
			 clickedDataSet.push([ x, y, text ]);
			 }
			 }
			 ;

			 // add rectangles
			 var fontSize = 14;
			 var padding = 2;
			 var rectHeight = fontSize + 2 * padding; //based on font size

			 parcoords.svg.selectAll("rect[id='tooltip']").data(
			 clickedDataSet).enter().append("rect").attr("x",
			 function(d) {
			 return d[0] - d[2].length * 5;
			 }).attr("y", function(d) {
			 return d[1] - rectHeight + 2 * padding;
			 }).attr("rx", "2").attr("ry", "2").attr("id", "tooltip").attr(
			 "fill", "grey").attr("opacity", 0.9).attr("width",
			 function(d) {
			 return d[2].length * 10;
			 }).attr("height", rectHeight);

			 // add text on top of rectangle
			 parcoords.svg.selectAll("text[id='tooltip']").data(
			 clickedDataSet).enter().append("text").attr("x",
			 function(d) {
			 return d[0];
			 }).attr("y", function(d) {
			 return d[1];
			 }).attr("id", "tooltip").attr("fill", "white").attr(
			 "text-anchor", "middle").attr("font-size", fontSize)
			 .text(function(d) {
			 return d[2];
			 })
			 }

			 function getClickedLines(mouseClick) {
			 var clicked = [];
			 var clickedCenPts = [];

			 // find which data is activated right now
			 var activeData = getActiveData();

			 // find centriod points
			 var graphCentPts = getCentroids(activeData);

			 if (graphCentPts.length == 0)
			 return false;

			 // find between which axes the point is
			 var axeNum = findAxes(mouseClick, graphCentPts[0]);
			 if (!axeNum)
			 return false;

			 graphCentPts.forEach(function(d, i) {
			 if (isOnLine(d[axeNum - 1], d[axeNum], mouseClick, 2)) {
			 clicked.push(activeData[i]);
			 clickedCenPts.push(graphCentPts[i]); // for tooltip
			 }
			 });

			 return [ clicked, clickedCenPts ]
			 }

			 function highlightLineOnClick(mouseClick, drawTooltip) {

			 var clicked = [];
			 var clickedCenPts = [];

			 clickedData = getClickedLines(mouseClick);

			 if (clickedData && clickedData[0].length != 0) {

			 clicked = clickedData[0];
			 clickedCenPts = clickedData[1];

			 // highlight clicked line
			 parcoords.highlight(clicked);

			 if (drawTooltip) {
			 // clean if anything is there
			 cleanTooltip();
			 // add tooltip
			 addTooltip(clicked, clickedCenPts);
			 }

			 }
			 };*/
		</script>
	</div>

</body>

</html>